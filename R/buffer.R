#' Apply an inclusion radius and exclusion buffer to indices
#'
#' @param data An object of class `sf` or `sfc`.
#' @param indices List of indices in each fold generated by `split_unnamed`.
#' @param radius Numeric: points within this distance of the initially-selected
#' test points will be assigned to the assessment set.
#' @param buffer Numeric: points within this distance of the test set area
#' (that is, the area within `radius` distance of the initial test points)
#' will be assigned to neither the analysis or assessment set.
#' @param ... Arguments passed to [sf::st_buffer()]. Note that both the `radius`
#' and `buffer` zones are created using [sf::st_buffer()], so any arguments
#' passed through `...` will be applied to both.
buffer_indices <- function(data, indices, radius, buffer, ...) {
  n <- nrow(data)
  # radius_polygons are needed if `buffer` != 0, regardless of `radius`
  # so create them no matter what `radius` is set to:
  radius_polygons <- lapply(
    indices,
    function(x) {
      x <- sf::st_combine(data[x, ])
      sf::st_buffer(x, dist = radius, ...)
    }
  )

  # but don't bother checking intersections if `radius` is 0:
  if (radius) {
    indices <- purrr::map2(
      radius_polygons,
      indices,
      data_intersects_polygon,
      data = data
    )
  }

  # similarly, `buffer_indices` are _always_ needed
  # so initialize to integer(0) before checking if we need to find them:
  buffer_indices <- lapply(seq_along(indices), function(x) integer(0))
  if (buffer) {
    buffer_polygons <- lapply(
      radius_polygons,
      function(x) sf::st_buffer(sf::st_combine(x), dist = buffer, ...)
    )

    buffer_indices <- purrr::map2(
      buffer_polygons,
      indices,
      data_intersects_polygon,
      data = data
    )
  }

  indices <- purrr::map2(indices, buffer_indices, buffered_complement, n = n)
}

buffered_complement <- function(ind, buff_ind, n) {
  list(
    analysis = setdiff(1:n, c(ind, buff_ind)),
    assessment = unique(ind)
  )
}

data_intersects_polygon <- function(intersection_layer, existing_indices, data) {
  new_idx <- which(purrr::map_lgl(
    sf::st_intersects(data, sf::st_combine(intersection_layer)),
    ~ !identical(.x, integer(0))
  ))
  unique(c(existing_indices, new_idx))
}
