#' Apply an inclusion radius and exclusion buffer to indices
#'
#' @param data An object of class `sf` or `sfc`.
#' @param indices List of indices in each fold generated by `split_unnamed`.
#' @param radius Numeric: points within this distance of the initially-selected
#' test points will be assigned to the assessment set.
#' @param buffer Numeric: points within this distance of the test set area
#' (after `radius` is applied)
#' will be assigned to neither the analysis or assessment set.
#'
#' @keywords internal
buffer_indices <- function(data, indices, radius, buffer) {

  if (sf::st_is_longlat(data) && !sf::sf_use_s2()) {
    rlang::abort(
      c(
        "`buffer` and `radius` can only be used with geographic coordinates when using the s2 geometry library",
        "i" = "Reproject your data into a projected coordinate reference system using `sf::st_transform()`",
        "i" = "Or install the `s2` package and enable it using `sf::sf_use_s2(TRUE)`"
      )
    )
  }

  n <- nrow(data)

  if (is.null(radius)) radius <- 0
  if (is.null(buffer)) buffer <- 0

  if (radius) {
    indices <- row_ids_within_dist(data, indices, radius)
  }

  # `buffer_indices` are _always_ needed
  # so initialize to integer(0) before checking if we need to find them:
  buffer_indices <- lapply(seq_along(indices), function(x) integer(0))
  if (buffer) {
    buffer_indices <- row_ids_within_dist(data, indices, buffer)
  }

  purrr::map2(indices, buffer_indices, buffered_complement, n = n)
}

buffered_complement <- function(ind, buff_ind, n) {
  list(
    analysis = setdiff(1:n, c(ind, buff_ind)),
    assessment = unique(ind)
  )
}

row_ids_within_dist <- function(data, indices, dist) {
  purrr::map(
    # indices is the output of split_unnamed
    indices,
    # which_within_dist returns a vector of row IDs in sequential order
    #
    # In order to visualize (eventually) which observations were originally
    # chosen for the test set and which were inside `radius`,
    # we want the new indices to be appended to the end of the original indices,
    # not sorted in
    #
    # So here we append the new indices to the old and de-duplicate them
    ~ unique(c(.x, which_within_dist(data, .x, dist)))
  )
}

# Return row IDs for which elements of `data` are within `dist` of `data[idx, ]`
# Note that data[idx, ] are within any positive distance of themselves
# and as such are returned by this function
which_within_dist <- function(data, idx, dist) {
  which(
    purrr::map_lgl(
      sf::st_is_within_distance(data, data[idx, ], dist = dist),
      sgbp_is_not_empty
    )
  )
}
