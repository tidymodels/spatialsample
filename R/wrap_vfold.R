#' V-Fold Cross-Validation with Buffering
#'
#' V-fold cross-validation (also known as k-fold cross-validation) randomly
#' splits the data into V groups of roughly equal size (called "folds").
#' A resample of the analysis data consists of V-1 of the folds while the
#' assessment set contains the final fold.
#' This function adds the ability to apply an inclusion radius and exclusion
#' buffer to the assessment set, ensuring that your analysis data is spatially
#' separated from the assessment set.
#' In basic V-fold cross-validation (i.e. no repeats), the number of resamples
#' is equal to V.
#'
#' @details
#' When `radius` and `buffer` are both `NULL`, `spatial_buffer_vfold_cv`
#' is equivalent to [rsample::vfold_cv()] and `leave_location_out_cv` is
#' equivalent to [rsample::group_vfold_cv()].
#'
#' @inheritParams rsample::vfold_cv
#' @inheritParams rsample::group_vfold_cv
#' @inheritParams buffer_indices
#'
#' @references
#'
#' K. Le Rest, D. Pinaud, P. Monestiez, J. Chadoeuf, and C. Bretagnolle. 2014.
#' "Spatial leave-one-out cross-validation for variable selection in the
#' presence of spatial autocorrelation," Global Ecology and Biogeography 23,
#' pp. 811-820, doi: 10.1111/geb.12161.
#'
#' H. Meyer, C. Reudenbach, T. Hengl, M. Katurji, and T. Nauss. 2018.
#' "Improving performance of spatio-temporal machine learning models using
#' forward feature selection and target-oriented validation,"
#' Environmental Modelling & Software 101, pp. 1-9,
#' doi: 10.1016/j.envsoft.2017.12.001.
#'
#' @rdname spatial_vfold
#'
#' @examplesIf sf::sf_use_s2() && rlang::is_installed("modeldata")
#' boston_vfold <- spatial_buffer_vfold_cv(boston_canopy, buffer = 500)
#' data(ames, package = "modeldata")
#' ames_sf <- sf::st_as_sf(ames, coords = c("Longitude", "Latitude"), crs = 4326)
#' ames_neighborhoods <- spatial_leave_location_out_cv(ames_sf, Neighborhood)
#'
#' @export
spatial_buffer_vfold_cv <- function(data,
                                    v = 10,
                                    radius = NULL,
                                    buffer = NULL,
                                    repeats = 1,
                                    strata = NULL,
                                    breaks = 4,
                                    pool = 0.1,
                                    ...) {

  n <- nrow(data)
  v <- check_v(v, n, "rows")

  indices <- rsample::vfold_cv(
    data = data,
    v = v,
    repeats = repeats,
    strata = strata,
    breaks = breaks,
    pool = pool,
    ...
  )

  cv_att <- list(v = v,
                 repeats = repeats,
                 strata = !is.null(strata),
                 radius = radius,
                 buffer = buffer)

  if ("sf" %in% class(data)) {
    rset_class <- c("spatial_buffer_vfold_cv", "spatial_rset", "rset")
    rsplit_class <- c("spatial_buffer_vfold_split", "spatial_rsplit")
  } else {
    rset_class <- c("spatial_buffer_vfold_cv", "rset")
    rsplit_class <- c("spatial_buffer_vfold_split")
  }

  wrap_vfold(
    data = data,
    indices = indices,
    rsplit_class = rsplit_class,
    rset_class = rset_class,
    radius = radius,
    buffer = buffer,
    n = n,
    v = v,
    cv_att = cv_att
  )

}


#' @rdname spatial_vfold
#'
#' @export
spatial_leave_location_out_cv <- function(data,
                                          group = NULL,
                                          v = NULL,
                                          radius = NULL,
                                          buffer = NULL,
                                          ...) {

  if (!missing(group)) {
    group <- tidyselect::eval_select(rlang::enquo(group), data)
  }

  if (length(group) == 0) {
    group <- NULL
  } else {
    if (is.null(v)) v <- length(unique(data[[group]]))
    v <- check_v(v, length(unique(data[[group]])), "locations")
  }

  n <- nrow(data)

  indices <- rsample::group_vfold_cv(
    data = data,
    v = v,
    group = group,
    ...
  )

  cv_att <- list(v = v,
                 group = group,
                 radius = radius,
                 buffer = buffer)

  if ("sf" %in% class(data)) {
    rset_class <- c("leave_location_out_cv", "spatial_rset", "rset")
    rsplit_class <- c("leave_location_out_split", "spatial_rsplit")
  } else {
    rset_class <- c("leave_location_out_cv", "rset")
    rsplit_class <- c("leave_location_out_split")
  }

  wrap_vfold(
    data = data,
    indices = indices,
    rsplit_class = rsplit_class,
    rset_class = rset_class,
    radius = radius,
    buffer = buffer,
    n = n,
    v = v,
    cv_att = cv_att
  )

}

wrap_vfold <- function(data,
                       indices,
                       rsplit_class,
                       rset_class,
                       radius,
                       buffer,
                       n,
                       v,
                       cv_att) {
  # This basically undoes everything post-`split_unnamed` for us
  # so we're back to an unnamed list of assessment-set indices
  indices <- purrr::map(indices$splits, as.integer, "assessment")

  if (is.null(radius) && is.null(buffer)) {
    indices <- lapply(indices, default_complement, n = n)
  } else {
    indices <- buffer_indices(data, indices, radius, buffer)
  }

  split_objs <- purrr::map(
    indices,
    make_splits,
    data = data,
    class = rsplit_class
  )

  split_objs <- tibble::tibble(
    splits = split_objs,
    id = names0(length(split_objs), "Fold"),
    v = v
  )

  new_rset(
    splits = split_objs$splits,
    ids = split_objs[, grepl("^id", names(split_objs))],
    attrib = cv_att,
    subclass = rset_class
  )

}
